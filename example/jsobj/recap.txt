crud => 객체의 속성은 delete 키워드를 사용해야 한다.

객체의 프로퍼티(속성)은 맵과 유사한 방식으로 동작한다.
이름와 값의 연결로 이루어져있다.

직접 만든 객체 내부의 함수에서 this 키워드를 사용할 때는 조심해야한다.
es6 기반의 arrow func는 이 키워드를 지원하지 않는다.

객체는 키와 밸류의 짝일뿐이다. 밸류가 함수의 리턴이라면 키값으로 함수를 호출하는 것과 동일한
동작을 할 것이다

객체의 키값에 소괄호를 추가하지 않는다면 함수를 호출하는 시작점을 레퍼런스로 해서
실행되지 않은 함수를 리턴 할 것이다.

객체는 직접 생성할 수도 있지만, 생성자를 통해서 생성 할 수도 있다.
하나의 추상적인 캡슐의 프로토 타입을 만들어서
테스트 할때는 직접 생성 할 수도 있다.

그것을 이용해서 여러 캡슐을 찍어낼 때는 생성자가 필요할 것이다.

생성자로 객체를 생성할려면 생성자 함수가 있어야 한다고 한다.
해당 함수는 new 키워드를 사용하면 키와 밸류로 이루어진
객체를 리턴해준다. >> 레퍼런스 타입의 값을 리턴하는 것일 듯 하다.
자세한 내부동작은 잘 모르지만 말이다...

해당 리턴된 객체를 받을 변수가 있다면, 여태 사용하던 방식대로
객체를 요리하면 된다.

프로토타입
키와 밸류로 이루어진 객체는
생성자를 통해 많은 객체를 생성할 경우
레퍼런스 타입의 데이터는 그 형식을 지닌 채로 복제될 것이다.
그리고 이것이 함수이며, 이 함수를 사용하지 않는다면 메모리의 낭비가 생길 것이다.

이때 프로토타입을 사용한다면 객체 생성시마다 함수를 사용하는 것이 아닌,
생성후 사용할때 생성되는 것으로 보인다.

함수는 선언문에서(statement) 선언되고 
생성자라는 지위를 얻는다. 그리고 그때 자신의 프로토타입을 만들게 된다.
이때 이 프로토타입을 '프로토타입 객체' 라고 부른다.
모든 함수는 이 '프로토타입 객체' 를 가지고 있다.
그리고 함수는 '프로토타입' 속성을 가지고 있으며 여기에 자신의 '프로토타입 객체'를 가리킨다.
'프로토타입 객체' 는 '생성자' 속성 을 가지고 있으며, 여기에는 자신을 만든 함수를 가리킨다.
(코드로 접근 불가능함)
그 둘은 짝꿍이다.
생성자 지위를 가진 함수는 new 키워드를 통해서 객체를 만들어 낼 수 있는데,
이렇게 생성된 객체에는 '프로토타입 라인' 이라고 불리는 숨겨진 '_proto_' 속성이 있고
이 '_proto_' 속성에는 자신을 만든 생성자의 프로토타입 속성에 적혀있는 
--'프로토타입 객체'-- 를 가리키고 있다.

모든 객체는 '_proto_' 속성을 가지고 있으며,
함수는 function 객체의 prototype을 '_proto_' 속성으로 가진다.

클래스는 자바 클래스랑 똑같다.
생성자는 constructor 키워드로 정의되어 있다.
해당 키워드로 유사함수를 만들면 된다.

상속도 있다.
모든 객체는 '__proto__' 속성을 가진다고 했는데,
이 속성에 부모객체의 참조값을 넣으면 된다.
하지만 이것은 비표준 방식이다.

표준 방식은 object.create() 메서드를 사용하는것이다.
물론 이 모든 방식은 생성자 함수를 통해 생성한 객체들의 상속관계를
정리하는 것이 아닌
json 으로 표기되는 객체들을 개별적으로 상속시킬때 쓰는 방식이다.

call 함수

모든 함수는 call 메서드를 가지고 있다.
해당 메서드의 쓰임은 매우 많지만
그중 하나는 객체를 첫번째 인자로 넣을때 해당 객체가
해당 함수를 속성에 대한 값으로 가진것처럼 동작하는 것이다.
두번재 인자부터는 원래 함수의 인자값을 넣으면 된다.

bind 함수

역시 모든 함수는 bind 메서드를 가지고 있다.
해당 함수의 리턴은 함수이며,
bind는 인자로 binded되는 함수가 요구하는 인자를 두번째 인자로 받으며
binding 되는 객체를 첫번째 인자로 받는다.
이렇게 되면
리턴된 함수는 객체와 높은 결합을 하게 된다.
그리고 이 함수는 기존 함수를 복사하는 방식이다.
변수 어딘가에 할당한다면 계속 결합을 유지할 것이다.