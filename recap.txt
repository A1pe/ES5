----------------------------------변수와 자료형 -----------------------------------
자바스크립트의 변수는 전부 다 참조변수를 활용한 객체다.
var a = 4 는

var a = new Number(4) 와 같다. 자동 wrapper 기능이 내장되어 있고
number 클래스의 메서드를 사용 할 수 있다.
이러한 wrapper 클래스의 종류는 부울형, 숫자형, 문자형 세가지가 있다.

---------------------------------배열객체와 메서드 --------------------------------

자바스크립트는 배열을 stack 방식으로 사용할 수 있다.
메서드 별로 기능이 다 있다.

push 메서드와 pop 메서드만을 이용해야 한다.

물론 이 배열객체에는 list의 기능도 있다.
충격스럽게도 배열객체를 처음 생성하고 인덱스를 0보다 큰 인덱스에 대입을 하면
그 인덱스보다 적은 인덱스를 모조리 생성하고
빈 객체를 참조해버린다.

충격적이게도 배열의 안에는 다른 자료형을 넣을 수도 있고 배열이 중첩 될 수도 있다.

list의 splice 라는 메서드가 있다. 이는 특정 인덱스 이후의 데이터를 조작하는 메서드다.

array.splice(2,1) >>>> 이것은 2번째 인덱스 부터 첫번째 데이터를 삭제하지만

array.splice(2,1,"hau") >> 이것은 삭제한 뒤에 3번째 인자를 대입한다.

array.splice(2,0,"hau") >> 심지어 이것은 삭제하지 않고 그 자리에 3번째 인자를 삽입한다.


--------------------------------object 정의----------------------------------------

제일 이질적인 것 같다. 기존의 언어는 class 파일을 생성한뒤 그 파일에 정의된 것을 바탕으로
객체를 생성했다. 하지만 자바스크립트는 하나의 파일에서 객체를 맨땅에 생성하고 사용한다(.....)

var exam = new Object() >> 맨땅에 객체 초기화
exam.kor = 30 >>>>> 느닷없이 객체에 값 집어넣기....이것을 동적인 방식이라고 한다고 한다.(expand object)

자바스크립트는 map 자료형을 오브젝트가 제공한다.
즉 key 값에 의한 value 를 가져 올 수가 있다.

var exam = new Object();
exam["kor"] = 30; >> key 값 kor에 30이라는 value가 들어있음.

alert(exam["kor"]) >> 30 출력됨.

json이 정의되면서 key에 의한 value가 당연하게 됨. 내부에서 자동으로 문자열로 인식함.

var exam{           var exam{
    id: 10,             "id" : 10,
    avg: 21 >>>>>>>     "avg" : 21
    }               }

만약 이스케이프 시퀸스가 포함된 문자열을 객체의 값의 key로 설정하고 싶다면 그때는 쿼테이션을 붙여야 함.
물론 그 데이터에 접근할때도 이전처럼 ["keyName"] 방식을 사용해야 함.

-----------------------------JSON----------------------------------------------

json 은 javascript object notation 의 약자이다.
그냥 우리가 쌩 new 연산자와 생성자를 이용해서 생성하는 것들을
그게 아니라 보기 편하게 표기하도록 하는 방식이다.

내부적인 처리가 어떻게 되는지 안보여주고 겉모습만 이쁘게 보여주는 것이다.
컨트롤 k + c >>> 범위주석 히히

json 표기로 넘어오면서 이 표기법이 적당히 가볍고 적당히 무거운
데이터를 표현할 수가 있다는 것을 알게되자
이 방식을 이용해서 데이터를 저장하고 받는 방식이 매우 유행하게 되었다.

이런 데이터를 넘겨받으면 대부분이 문자열로 이루어져 있음을 알게 된다.
이런 문자열로 된 데이터에서 원하는 데이터를 추출하는 방법으로
eval 함수와 json parser 이라는 방법을 이용할 수 있다.

eval 함수는 인자로 넣은 문자열을 js코드로 바꿔준다.
그래서 실행시 인자로 넣는 문자열이 그대로 실행된다.
원한다면 문자열 안에 여러 로직을 넣어서 응용 할 수도 있다.

json parser 은 json 전용의 기능이다.

json 데이터를 읽기위해서는 JSON.parser 메서드를 사용해야 하며
인자로 넣는 데이터는 아주 엄격한 방식의 유효성 검사를 거치게 된다.
인자로 넣는 객체의 속성은 무조건 쿼테이션을 기입해주어야 한다.

그런 엄격한 검사를 거친다면 쿼테이션을 제거한 값을 리턴 해 줄 것이다.
반대로 json 파일 형식의 데이터를 생성해야 할 때도 있을 것이다.
이는 모든 속성에 쿼테이션을 추가해야 하는 극악의 난이도를 자랑한다.
하지만 이 모든 것은
JSON.stringify (문자열화) 메서드를 사용한다면 EASY 하게 바꿀 수 있을 것이다.

-------------------------------------------연산자-----------------------------------------

다 같다.
추가적으로 모르는 것만 기입.

=== 연산자와 !== 연산자.

=== 연산자는 참조한 것이 같은지를 확인한다.
그러나 상수는 한번 선언되었다면 그 선언된 놈을 다시 참조해서 메모리의 경제적인 사용을 꾀한다.

그러므로 상수는 참조한 것이 같다고 뜸.
만약 new 키워드를 사용해서 만든다면 같지 않다고 뜬다.

그리고 문자와 숫자의 연산시 덧셈은 묵시적으로 문자열로 변환해서 합쳐버리고
뺄셈시 숫자로 할 수 있다면 숫자로 만들어 버린다.(......)

대소 비교시에도 숫자로 바꿔서 해버린다...

-------------------------------------------함수-----------------------------------------------

자바스크립트는 매우 충격적이게도 함수조차도 객체다.

var add = new Function("x,y","return x+y;")

이것이 내부에서 일어나는 충격적인 모습이다.
하지만 이런 특징으로 인해서 정의도 필요없고 형식도 필요없는 모습을 보인다.

이런 내부의 모습과 외부의 모습의 괴리로 인해
하나의 로직을 여러 방식으로 표현하는 모습을 보인다.

1번 var add = new Function("x,y","return x+y;");

2번 var add = function(x,y){return x+y;};

3번 function(x+y){return x+y};

4번 add(x,y) => x+y;

5번 add(x,y) => {return x+y};

그야말로 문화충격

놀랍게도 매개변수는 의미가 없다.
사실 인자로 넣는 모든 값들은 argument 라는 컬렉션에 담기게 되는데
이 컬렉션에 들어간 데이터를 참조하는 것이 자바스크립트에서의 매개변수다.

즉 참조되지 않은 argument의 데이터를 객체로 만든 것이 rest 라는 것으로 볼 수 있다.

---------------------------------------------변수의 스코프----------------------------------------

사실 난 알고있다.
var 변수는 최상단에 객체를 생성하고
나중에 1을 참조한다는 사실을.

만약 var 키워드 없이 변수이름과 값을 넣는다면 그것은 전역객체의 속성을 띈다(...?)
window 라는 객체의 속성으로 들어간다고 한다.

**********************클로저*********************************

closure 는 자바스크립트에 있는 고유한 문제다.
함수의 탈을 쓴 객체이기 때문에
이 객체가 다른 함수의 탈을 쓴 객체를 반환하고

반환한 함수의 탈을 쓴 객체가 만약 이전의 함수가 가진 지역변수를 쓴다면
그 이전 함수는 생명주기가 프로그램 종료까지 이어지는 현상이 일어난다.
이런 함수가 자신이 쓴 자원을 반납하지 않고 죽지못하는 몸이 되어버릴때
고칠수 있는 방법은
자신이 리턴한 함수를 참조하는 변수가 아무것도 참조하지 않게 될 때다.
이런 자신이 리턴한 함수로 인해 자원을 반납하지 못할때
자신이 리턴한 함수는 자신을 죽일수 있는 유일한 놈이니
이 반환한 놈을 클로저라고 부른다.

이를 스스로 잘 알고 사용하면 유용할 수 있으나
모르고 사용하거나 잘 모른채로 사용하면 문제가 클 것이다.

---------------------------------------browser object---------------------------------------

브라우저가 가진 도구는 매우 많다. 
자바스크립트는 이런 브라우저가 가진 기능을 이용할 수 있다.

이런 기능을 제공하는 객체를 window 객체라고 부른다.
예시를 들면 우리가 사용하는 url을 입력하는 부분을
window.location 객체라고 부른다.
이것을 조작하면 url에 넣은 값을 바꾸거나 컨트롤 할 수 있고
뒤로가기, 앞으로 가기 버튼도 제어 할 수 있다.
이것을 window.history 라는 객체에 있다.
그리고 화면에 표시되는 스타일이나 보이는 모습또한 제어할 수 있는데
이는 window.document 라는 객체가 담당하고 있다.
그리고 document는 html에 작성된 태그들의 계층구조가 그대로 똑같이 속성으로 가지고 있다. 

일단 큰 기능이 담긴 객체는 나중에 알아보고
윈도우 객체 자체가 가진 메서드들을 알아보는 것이 순서상 좋을 것이다.

* alert => 알림창 표시.
첫번째 인자 : 사용자에게 표시할 내용

참고로 window 라는 객체는 생략이 가능하다.

* prompt => 입력창 표시
첫번째 인자 : 사용자에게 표시할 내용
두번째 인자 : 기본값

입력받은 창은 문자열로 저장됨.
parseInt 와 같은 자바스크립트 제공 함수를 사용하면 쉽게 연산에 사용할 수 있다.

* confirm => 확인 및 취소창 표시
첫번째 인자 : 사용자에게 표시할 내용

확인시 참값, 취소시 거짓값을 반환함.

******************이벤트 기반의 프로그래밍 기법*************************

자바스크립트는 script 라는 태그 안에만 사용 가능한 것은 아니다.

onClick, onmouseover 같은 태그의 속성 안에서도 사용이 가능하다.

script 태그 내부의 코드는 페이지가 읽힐때 바로 발생하고
태그 안에있는 이벤트 관련 속성안의 코드는 해당 이벤트가 발생할 때 마다
코드가 실행된다.

헤드태그 내부의 스크립트 태그 안에 함수를 미리 만들어두고
이벤트가 발생할때마다 해당 함수가 실행되도록 할 수 있다.

*****************element 객체 사용하기*********************************

html 파일은 브라우저가 로드하면 자바스크립트가 이용할 수 있도록
태그들의 구조를 객체화 시켜둔다.
이것을 Document Objects 라고 부르고
객체 트리라고도 부른다.
실제로 트리 구조다.
그리고 공통적으로 태그를 엘리먼트 객체라고 부른다.
태그 내부에 있는 텍스트는 텍스트 노드 객체라고 부른다.
폼 같은 태그는 엘리먼트 노드 객체라고도 부른다.

주석은 노드 객체로 올라간다.

이런 트리 구조를 브라우저는 읽어서 우리에게 보여준다.

개발자라면 이런 트리 구조에 있는 노드에 해당하는
객체를 컨트롤 할 줄 아는것이 바람직할 것이다.

이런 객체를 컨트롤 하는 방법으로는 id를 이용하는 방법이 있다.

주의할 점으로는 코드의 유지보수 및 관리를 위해서
script 태그를 head 에 두는 경우가 있는데
이럴 때는 html 특성상, 위쪽에서 읽기 때문에
id 속성이 미리 정해지기 전에 자바스크립트가 먼저 읽히게 된다.
결국 undefiend 되게 된다.
(함수 내부는 상관없다. 함수 객체 밖에있는
특정한 엘리먼트 객체의 id에 함수객체를 참조시켜야 하는데
그 특정한 엘리먼트 객체가 로딩되기 전이기 때문에 자바스크립트 입장에서는
알 수가 없다.)

해결책중 하나는 script 태그를 문서의 맨 아래에 두는 것이다.
하지만 이 방법보다 더 좋은 방법은 두번째 방법이다.
두번째로는 브라우저 안쪽의 엘리먼트 객체와 자원이 모두 읽힌다면
onload 라는 이벤트가 발생하는데,
이 이벤트가 발생한 뒤에 자바스크립트가 동작하게 하도록 만드는것이
좀 더 바람직할 것이다.

사실 세부적인 문제가 있다.
태그에 id를 부여할 때 html에서 사용하는 방식으로 이름을 명명하면(btn-print)
자바스크립트에서는 저 이름에 접근 할 수 없다.
왜냐하면 변수명으로 허용되지 않기 때문이다.
그래서 document 객체의 getElementbyId 같은 메서드를 이용해서 저런
거지같은 이름을 불러서 맞는 이름으로 바꿔주어야 한다. 

두번째 문제로 지역의 문제가 있을 것이다.
이는 함수 자체가 변수에 대입이 가능한 객체라는 특징을 가짐을 이용하면
함수의 이름없이 그냥 대입하는식으로 함수 안쪽의 지역을 공유함으로서
문제를 해결 할 수 있다.

첫번째 두번째를 해결하면 다른 문제가 생긴다.
바로 코드를 분리해서 생기는 문제다.
만약 서로 다른 js코드를 하나의 html에서 사용한다고 하면
모든 js는 window.onload 이벤트가 발생하는것을 기다릴 것이다.
이 이벤트에 함수를 대입하는 방식으로 말이다.
이렇게되면 이 이벤트에 대입된 이벤트가 한개가 아니므로 값이 덮어씌어질것이다.
즉 맨 마지막 스크립트만 동작하는 것이다.

이런 상황을 해결하기 위해서는 onload에 값을 대입하는게 아니라 누적시키는 방법을 사용해야 한다.
이것은 window 객체의 addEventListener 메서드를 사용하면 된다.

노드 엘리먼트를 찾는 방법은 id로 찾는 방식이 있다고 했다.
하지만 모든 노드 엘리먼트에 id를 부여하기 보다는
상위 부모 노드 한개에 id를 부여하고
상대적인 경로를 찾아서 가는것이 편할수도 있다.

그리고 엘리먼트를 찾는 방법은 2가지가 더 있다.

getElementsByTagName 이라는 메서드와
getElementsByClassName 이라는 메서드가 있다.
두개 다 배열객체로 값을 반환해준다.

만약
<section id = "sec1">
    <h1></h1>
    <ul>
       <li></li>
       <li></li>
      <li></li>
    </ul>
</section>

가 있다면, 해당 상위태그인 section의 id를 이용해서 노드 엘리먼트를 생성하고
=> var sec1 = window.getElementbyId("sec1");
해당 생성한 노드객체에는 하위 노드 객체에 대한 정보가 있으니
태그명이나 클래스 명으로 접근하는 방법이 바람직할 것이다.
=> var lis = sec1.getElementsByTagName("li");
=> lis[0].textContent = "hello";

그리고 최근에는 SelectorAPI 를 사용해서 노드 엘리먼트를 가져오는것이 더 바람직하다고 한다.
그 기능중 두개는 querySelector 과 querySelectorAll 이 있다.
css 의 선택자를 이용하면 아주 세밀하게 모든 태그를 선택할 수 있다.
그러므로 보다 쉽게 노드에 접근하기가 용이할 것이다.

엘리먼트와 노드는 다른 것이다. 주의해야 한다.
노드에는 주석, 텍스트, 빈공백 전부 다 객체로 되어있다.
그러므로 일반적인 html 작성후 노드를 가져온다면
생각치 못한 노드들이 배열객체에 담겨져 있을 것이다.

이런 태그 엘리먼트에 접근하고 싶다면
childNode 메서드가 아닌
children 메서드를 사용해야 한다. 무조건.

--------------------------------------노드---------------------------------

노드의 종류를 알아보자.
노드라고 부르지만 그 노드들에는 타입이 있다.
노드에는 텍스트, 주석, 태그가 전부 포함되어 있는데
그것을 구분하는 방법으로는 노드의 타입이 어떻게 되어있는지를 확인하면 된다.

document 노드는 문서 전체라고 보면 된다.
그 document 노드를 이루는 것들을 알아보자.

DocumentType 이라는 타입은 html 맨 상단에 있는 DOCTYPE를 말한다.

엘리먼트라는 타입은 태그와 그 내용을 전부 다 포함한다.

엘리먼트 타입의 하위 속성으로 attrubute는 tag의 속성을 말한다.

엘리먼트 타입의 하위 속성으로 entity 라는 속성은 html에서
사용하는 예약어와 충돌되는 내용이 content(<tag>content</tag>)에
적혀있을때 대신 사용되는 키워드를 말하며, 이 내용이 적혀있다.

엘리먼트 타입의 하위 속성인 entity reference 는 entity에 사용되는
(&entity;) 내용을 열고 닫는 &와 ;가 어디에 사용될지 알려준다.

엘리먼트 타입의 하위 속성인 text는 태그 안쪽의 내용을 저장해둔다.

다른 타입으로 comment가 있으며 여기에는 주석에 대한 정보가 있다.

notation이라는 타입은 attrubute에 들어가는 값에 대한 정보가 있다.

이론적으로는 노드라는 추상적인 자료에 저런 데이터가 있고
이제 이 구조를 알았으니 프로그램을 만들 때 원하는 데이터에 접근하기가
한층 용이할 것이다.

자바스크립트를 다룬다는 것은 이 노드들중 엘리먼트를 주로 다루게 될 것이며
엘리먼트의 텍스트나 document와 attribute도 가끔 다루게 될 것이다.

---------------------------node 인터페이스------------------------------------

노드를 조작할려면 노드 인터페이스를 사용해야 할 것이다.
이 인터페이스에는 노드를 조작하는 도구들이 잔뜩 담겨있다.

이 기능이 무엇이 있는지 알아야 사용할때도 눈뜬 장님이 되지 않을 것이다.
그리고 노드가 공통적으로 가진 기능, document만 가지고 있는 특별한 기능을 알아두면
좋을 것이다.

html class = javascript className
자바스크립트에는 class가 이미 예약어로 존재하므로 className 이라는 예약어를 대신 사용해야함.

새로 생성한 노드는 append 메서드로 자식노드의 뒷쪽에 삽입 할 수도 있다.
물론 insert 메서드를 이용해서 중간에 삽입 할 수 도 있다.
모든 노드는 document의 기능을 이용해서 만들어야 한다.

ex ) createElement, createTextNode 2가지를 관심있게 보면 될듯

------------------------------노드 생성---------------------------------

당연하지만 엘리먼트를 생성하고 그 안에 텍스트 노드를 추가해야 한다.
그냥 쌩 텍스트 노드를 추가하면 텍스트만 덩그러니 있게 된다.

완전 초기방법
  
엘리먼트를 생성     document.createElement("생성할 엘리먼트")
텍스트노드 생성     document.createTextNode("삽입할 텍스트 내용")

엘리먼트를 삽입     부모태그객체.appendChild("생성한 엘리먼트")
텍스트를 삽입       생성한엘리먼트.appendChild("생성한 텍스트노드")

******* 문제점 : html 문서량이 많아질수록 요구하는 코드량이 매우 많이 늘어남 **********

중간에 개선된 방식

태그를 문자열로생성  var html = '<li><a href="">' + '삽입할 텍스트 내용' + '</a></li>' 
태그삽입            부모태그겍체.innerHTML += html;

****** 문제점 : 적재 방식이 아닌 대입 방식이기에 하나의 태그를 임시로 삽입할때는 문제가 없으나
              : 여러 태그를 지속적으로 적재시(+= 연산자 사용) 성능저하가 생김


훨씬 개선된 방식

엘리먼트를 생성     document.createElement("생성할 엘리먼트")  => 주로 내용이 담길 박스
태그를 문자열로생성 var html = '<a href="">' + '삽입할내용' + '</a>'

엘리먼트를 삽입     부모태그겍체.appendChile("생성한 엘리먼트")
세부적인 태그 삽입  생성한 엘리먼트.innerHTML = html

장점 : 성능저하 없이 코드량이 줄어들음

추가로 메서드가 개선됨

appendChild >> append
append 메서드는 string 값의 객체가 인자로 주어지면 텍스트 노드로 래핑해서 자식으로 넣어준다.
변수 래핑과 비슷한 느낌
그리고 엘리먼트 여러개를 동시에 넣을 수 있음.
removeChild >> remove
removeChild 메서드는 자식 객체를 인자로 넣어서 지워야 하지만 더 간단한 메서드가 생김.
remove 메서드는 자기 자신을 지워버린다.

-----------------------------노드 복제 --------------------------------------------

노드를 복제하기 위해서는 특정 노드객체를 참조하는 변수가 필요하다.
해당 변수는 엘리먼트라는 자료형의 구현체이며
따라서 엘리먼트의 기능중(노드의 기능일수도?) 하나인 cloneNode 메서드를 사용하면 된다.
해당 메서드의 인자가 true라면 내부의 자식계층을 전부 복사한다.
그리고 입맛대로 내용물을 뜯어 고치고 삽입하면 수정하기가 용이할 것이다.

템플릿 복제는 조금 다르다.
템플릿 태그를 참조하는 변수가 필요하고, 해당 템플릿을 복제할려면
document의 importNode 메서드를 사용해야한다.
인자는 template.content, true 를 사용한다면
해당 템플릿의 껍데기와 내부 구조를 전부 다 긁어오게 된다.