----------------------------------변수와 자료형 -----------------------------------
자바스크립트의 변수는 전부 다 참조변수를 활용한 객체다.
var a = 4 는

var a = new Number(4) 와 같다. 자동 wrapper 기능이 내장되어 있고
number 클래스의 메서드를 사용 할 수 있다.
이러한 wrapper 클래스의 종류는 부울형, 숫자형, 문자형 세가지가 있다.

---------------------------------배열객체와 메서드 --------------------------------

자바스크립트는 배열을 stack 방식으로 사용할 수 있다.
메서드 별로 기능이 다 있다.

push 메서드와 pop 메서드만을 이용해야 한다.

물론 이 배열객체에는 list의 기능도 있다.
충격스럽게도 배열객체를 처음 생성하고 인덱스를 0보다 큰 인덱스에 대입을 하면
그 인덱스보다 적은 인덱스를 모조리 생성하고
빈 객체를 참조해버린다.

충격적이게도 배열의 안에는 다른 자료형을 넣을 수도 있고 배열이 중첩 될 수도 있다.

list의 splice 라는 메서드가 있다. 이는 특정 인덱스 이후의 데이터를 조작하는 메서드다.

array.splice(2,1) >>>> 이것은 2번째 인덱스 부터 첫번째 데이터를 삭제하지만

array.splice(2,1,"hau") >> 이것은 삭제한 뒤에 3번째 인자를 대입한다.

array.splice(2,0,"hau") >> 심지어 이것은 삭제하지 않고 그 자리에 3번째 인자를 삽입한다.


--------------------------------object 정의----------------------------------------

제일 이질적인 것 같다. 기존의 언어는 class 파일을 생성한뒤 그 파일에 정의된 것을 바탕으로
객체를 생성했다. 하지만 자바스크립트는 하나의 파일에서 객체를 맨땅에 생성하고 사용한다(.....)

var exam = new Object() >> 맨땅에 객체 초기화
exam.kor = 30 >>>>> 느닷없이 객체에 값 집어넣기....이것을 동적인 방식이라고 한다고 한다.(expand object)

자바스크립트는 map 자료형을 오브젝트가 제공한다.
즉 key 값에 의한 value 를 가져 올 수가 있다.

var exam = new Object();
exam["kor"] = 30; >> key 값 kor에 30이라는 value가 들어있음.

alert(exam["kor"]) >> 30 출력됨.

json이 정의되면서 key에 의한 value가 당연하게 됨. 내부에서 자동으로 문자열로 인식함.

var exam{           var exam{
    id: 10,             "id" : 10,
    avg: 21 >>>>>>>     "avg" : 21
    }               }

만약 이스케이프 시퀸스가 포함된 문자열을 객체의 값의 key로 설정하고 싶다면 그때는 쿼테이션을 붙여야 함.
물론 그 데이터에 접근할때도 이전처럼 ["keyName"] 방식을 사용해야 함.

-----------------------------JSON----------------------------------------------

json 은 javascript object notation 의 약자이다.
그냥 우리가 쌩 new 연산자와 생성자를 이용해서 생성하는 것들을
그게 아니라 보기 편하게 표기하도록 하는 방식이다.

내부적인 처리가 어떻게 되는지 안보여주고 겉모습만 이쁘게 보여주는 것이다.
컨트롤 k + c >>> 범위주석 히히

json 표기로 넘어오면서 이 표기법이 적당히 가볍고 적당히 무거운
데이터를 표현할 수가 있다는 것을 알게되자
이 방식을 이용해서 데이터를 저장하고 받는 방식이 매우 유행하게 되었다.

이런 데이터를 넘겨받으면 대부분이 문자열로 이루어져 있음을 알게 된다.
이런 문자열로 된 데이터에서 원하는 데이터를 추출하는 방법으로
eval 함수와 json parser 이라는 방법을 이용할 수 있다.

eval 함수는 인자로 넣은 문자열을 js코드로 바꿔준다.
그래서 실행시 인자로 넣는 문자열이 그대로 실행된다.
원한다면 문자열 안에 여러 로직을 넣어서 응용 할 수도 있다.

json parser 은 json 전용의 기능이다.

json 데이터를 읽기위해서는 JSON.parser 메서드를 사용해야 하며
인자로 넣는 데이터는 아주 엄격한 방식의 유효성 검사를 거치게 된다.
인자로 넣는 객체의 속성은 무조건 쿼테이션을 기입해주어야 한다.

그런 엄격한 검사를 거친다면 쿼테이션을 제거한 값을 리턴 해 줄 것이다.
반대로 json 파일 형식의 데이터를 생성해야 할 때도 있을 것이다.
이는 모든 속성에 쿼테이션을 추가해야 하는 극악의 난이도를 자랑한다.
하지만 이 모든 것은
JSON.stringify (문자열화) 메서드를 사용한다면 EASY 하게 바꿀 수 있을 것이다.

-------------------------------------------연산자-----------------------------------------

다 같다.
추가적으로 모르는 것만 기입.

=== 연산자와 !== 연산자.

=== 연산자는 참조한 것이 같은지를 확인한다.
그러나 상수는 한번 선언되었다면 그 선언된 놈을 다시 참조해서 메모리의 경제적인 사용을 꾀한다.

그러므로 상수는 참조한 것이 같다고 뜸.
만약 new 키워드를 사용해서 만든다면 같지 않다고 뜬다.

그리고 문자와 숫자의 연산시 덧셈은 묵시적으로 문자열로 변환해서 합쳐버리고
뺄셈시 숫자로 할 수 있다면 숫자로 만들어 버린다.(......)

대소 비교시에도 숫자로 바꿔서 해버린다...

-------------------------------------------함수-----------------------------------------------

자바스크립트는 매우 충격적이게도 함수조차도 객체다.

var add = new Function("x,y","return x+y;")

이것이 내부에서 일어나는 충격적인 모습이다.
하지만 이런 특징으로 인해서 정의도 필요없고 형식도 필요없는 모습을 보인다.

이런 내부의 모습과 외부의 모습의 괴리로 인해
하나의 로직을 여러 방식으로 표현하는 모습을 보인다.

1번 var add = new Function("x,y","return x+y;");

2번 var add = function(x,y){return x+y;};

3번 function(x+y){return x+y};

4번 add(x,y) => x+y;

5번 add(x,y) => {return x+y};

그야말로 문화충격

놀랍게도 매개변수는 의미가 없다.
사실 인자로 넣는 모든 값들은 argument 라는 컬렉션에 담기게 되는데
이 컬렉션에 들어간 데이터를 참조하는 것이 자바스크립트에서의 매개변수다.

즉 참조되지 않은 argument의 데이터를 객체로 만든 것이 rest 라는 것으로 볼 수 있다.

---------------------------------------------변수의 스코프----------------------------------------

사실 난 알고있다.
var 변수는 최상단에 객체를 생성하고
나중에 1을 참조한다는 사실을.

만약 var 키워드 없이 변수이름과 값을 넣는다면 그것은 전역객체의 속성을 띈다(...?)
window 라는 객체의 속성으로 들어간다고 한다.

**********************클로저*********************************

closure 는 자바스크립트에 있는 고유한 문제다.
함수의 탈을 쓴 객체이기 때문에
이 객체가 다른 함수의 탈을 쓴 객체를 반환하고

반환한 함수의 탈을 쓴 객체가 만약 이전의 함수가 가진 지역변수를 쓴다면
그 이전 함수는 생명주기가 프로그램 종료까지 이어지는 현상이 일어난다.
이런 함수가 자신이 쓴 자원을 반납하지 않고 죽지못하는 몸이 되어버릴때
고칠수 있는 방법은
자신이 리턴한 함수를 참조하는 변수가 아무것도 참조하지 않게 될 때다.
이런 자신이 리턴한 함수로 인해 자원을 반납하지 못할때
자신이 리턴한 함수는 자신을 죽일수 있는 유일한 놈이니
이 반환한 놈을 클로저라고 부른다.

이를 스스로 잘 알고 사용하면 유용할 수 있으나
모르고 사용하거나 잘 모른채로 사용하면 문제가 클 것이다.

---------------------------------------browser object---------------------------------------

브라우저가 가진 도구는 매우 많다. 
자바스크립트는 이런 브라우저가 가진 기능을 이용할 수 있다.

이런 기능을 제공하는 객체를 window 객체라고 부른다.
예시를 들면 우리가 사용하는 url을 입력하는 부분을
window.location 객체라고 부른다.
이것을 조작하면 url에 넣은 값을 바꾸거나 컨트롤 할 수 있고
뒤로가기, 앞으로 가기 버튼도 제어 할 수 있다.
이것을 window.history 라는 객체에 있다.
그리고 화면에 표시되는 스타일이나 보이는 모습또한 제어할 수 있는데
이는 window.document 라는 객체가 담당하고 있다.
그리고 document는 html에 작성된 태그들의 계층구조가 그대로 똑같이 속성으로 가지고 있다. 

일단 큰 기능이 담긴 객체는 나중에 알아보고
윈도우 객체 자체가 가진 메서드들을 알아보는 것이 순서상 좋을 것이다.

* alert => 알림창 표시.
첫번째 인자 : 사용자에게 표시할 내용

참고로 window 라는 객체는 생략이 가능하다.

* prompt => 입력창 표시
첫번째 인자 : 사용자에게 표시할 내용
두번째 인자 : 기본값

입력받은 창은 문자열로 저장됨.
parseInt 와 같은 자바스크립트 제공 함수를 사용하면 쉽게 연산에 사용할 수 있다.

* confirm => 확인 및 취소창 표시
첫번째 인자 : 사용자에게 표시할 내용

확인시 참값, 취소시 거짓값을 반환함.

******************이벤트 기반의 프로그래밍 기법*************************

자바스크립트는 script 라는 태그 안에만 사용 가능한 것은 아니다.

onClick, onmouseover 같은 태그의 속성 안에서도 사용이 가능하다.

script 태그 내부의 코드는 페이지가 읽힐때 바로 발생하고
태그 안에있는 이벤트 관련 속성안의 코드는 해당 이벤트가 발생할 때 마다
코드가 실행된다.

헤드태그 내부의 스크립트 태그 안에 함수를 미리 만들어두고
이벤트가 발생할때마다 해당 함수가 실행되도록 할 수 있다.

*****************element 객체 사용하기*********************************

html 파일은 브라우저가 로드하면 자바스크립트가 이용할 수 있도록
태그들의 구조를 객체화 시켜둔다.
이것을 Document Objects 라고 부르고
객체 트리라고도 부른다.
실제로 트리 구조다.
그리고 공통적으로 태그를 엘리먼트 객체라고 부른다.
태그 내부에 있는 텍스트는 텍스트 노드 객체라고 부른다.
폼 같은 태그는 엘리먼트 노드 객체라고도 부른다.

주석은 노드 객체로 올라간다.

이런 트리 구조를 브라우저는 읽어서 우리에게 보여준다.

개발자라면 이런 트리 구조에 있는 노드에 해당하는
객체를 컨트롤 할 줄 아는것이 바람직할 것이다.

이런 객체를 컨트롤 하는 방법으로는 id를 이용하는 방법이 있다.

주의할 점으로는 코드의 유지보수 및 관리를 위해서
script 태그를 head 에 두는 경우가 있는데
이럴 때는 html 특성상, 위쪽에서 읽기 때문에
id 속성이 미리 정해지기 전에 자바스크립트가 먼저 읽히게 된다.
결국 undefiend 되게 된다.
(함수 내부는 상관없다. 함수 객체 밖에있는
특정한 엘리먼트 객체의 id에 함수객체를 참조시켜야 하는데
그 특정한 엘리먼트 객체가 로딩되기 전이기 때문에 자바스크립트 입장에서는
알 수가 없다.)

해결책중 하나는 script 태그를 문서의 맨 아래에 두는 것이다.
하지만 이 방법보다 더 좋은 방법은 두번째 방법이다.
두번째로는 브라우저 안쪽의 엘리먼트 객체와 자원이 모두 읽힌다면
onload 라는 이벤트가 발생하는데,
이 이벤트가 발생한 뒤에 자바스크립트가 동작하게 하도록 만드는것이
좀 더 바람직할 것이다.

사실 세부적인 문제가 있다.
태그에 id를 부여할 때 html에서 사용하는 방식으로 이름을 명명하면(btn-print)
자바스크립트에서는 저 이름에 접근 할 수 없다.
왜냐하면 변수명으로 허용되지 않기 때문이다.
그래서 document 객체의 getElementbyId 같은 메서드를 이용해서 저런
거지같은 이름을 불러서 맞는 이름으로 바꿔주어야 한다. 